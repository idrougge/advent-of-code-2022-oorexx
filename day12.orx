/* Advent of code 2022, day 12, part 1+2 in Open Object REXX */
input = .stream~new('day12.txt')
height = input~lines
width = input~linein~length
map = .array~new(width, height)
visited = map~copy
input~seek('=1')
loop with index row item line over input
    say row line
    loop with index column item cell over line~makeArray('')
        --say column row cell
        map[column, row] = cell
        if cell = 'S' then start = (column, row)
    end
end

deltas. = 0
deltas.1.2 = -1
deltas.2.2 = +1
deltas.3.1 = -1
deltas.4.1 = +1

visited[start] = .true

shortest = traverse(start, .set~of(start[1] start[2]), map~items)
say shortest
exit
call render map
call render visited
exit

traverse: procedure expose map visited deltas.
use strict arg start, steps, shortest_yet
--if map[start] = 'E' then say 'Nådde E.'
--if map[start] = 'E' then exit
--say 'Står på' map[start] '('start[1]','start[2]')'
--say 'djup:' steps~items
if map[start] = 'z' then do
    --steps~append(x y)
    call plotpath steps
    return steps~items --exit
end
loop i = 1 to 4
    x = start[1]; y = start[2]
    dx = deltas.i.1; dy = deltas.i.2
    x += dx; y += dy
    --say '>' x y
    if x < 1 | y < 1 then iterate
    if x > map~dimension(1) then iterate
    if y > map~dimension(2) then iterate
    --if steps~hasItem(x y) then say x','y 'har redan besökts.'
    if steps~hasItem(x y) then iterate
    --say 'OK' map[x,y]
    delta = map[x,y]~c2d - map[start]~c2d
    if map[start] = 'S' then delta = 0
    if map[x,y] = 'E' then iterate
    --say 'delta' delta
    --visited[(x,y)] = .true
    if delta <= 1 then shortest_yet = min(shortest_yet, traverse((x,y), steps~copy~~put(x y), shortest_yet))
end
return shortest_yet

render: procedure
use strict arg map
loop y = 1 to map~dimension(2)
    line = ''
    loop x = 1 to map~dimension(1)
        line ||= map[(x,y)]
    end
    say line
end
return

plotpath: procedure expose map
use strict arg path
newmap = map~copy
loop y = 1 to map~dimension(2)
    loop x = 1 to map~dimension(1)
        newmap[(x,y)] = '.'
    end
end
do with index i item step over path until i = path~items - 1
    parse var step x y
    next = path[i + 1]
    parse var next nextx nexty
    letter = 'X'
    if nextx > x then letter = '>'
    if nextx < x then letter = '<'
    if nexty > y then letter = 'v'
    if nexty < y then letter = '^'
    newmap[x,y] = letter
end
call render newmap
return
::method deepCompare
